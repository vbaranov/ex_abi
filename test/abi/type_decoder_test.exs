defmodule ABI.TypeDecoderTest do
  use ExUnit.Case, async: true

  doctest ABI.TypeDecoder

  alias ABI.TypeDecoder
  alias ABI.TypeEncoder

  describe "decode/2 '{:int, size}' type" do
    test "successfully decodes positives and negatives integers" do
      positive_int = "000000000000000000000000000000000000000000000000000000000000002a"
      negative_int = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd8f1"
      result_to_decode = Base.decode16!(positive_int <> negative_int, case: :lower)

      selector = %ABI.FunctionSelector{
        function: "baz",
        types: [
          {:int, 8},
          {:int, 256}
        ],
        returns: :int
      }

      assert ABI.TypeDecoder.decode(result_to_decode, selector) == [42, -9999]
    end
  end

  describe "decode" do
    test "with string data" do
      types = [:string]
      result = ["dave"]
      assert result == TypeEncoder.encode(result, types) |> TypeDecoder.decode(types)
    end

    test "with dynamic array data" do
      types = [{:array, :address}]
      result = [[]]
      assert result == TypeEncoder.encode(result, types) |> TypeDecoder.decode(types)

      types = [{:array, :address}]
      result = [[<<0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 35>>]]
      encoded_result = TypeEncoder.encode(result, types)
      assert result == encoded_result |> TypeDecoder.decode(types)
    end

    test "with a fixed-length array of static data" do
      data =
        """
        0000000000000000000000000000000000000000000000000000000000000007
        0000000000000000000000000000000000000000000000000000000000000003
        0000000000000000000000000000000000000000000000000000000000000000
        0000000000000000000000000000000000000000000000000000000000000000
        0000000000000000000000000000000000000000000000000000000000000000
        0000000000000000000000000000000000000000000000000000000000000005
        """
        |> encode_multiline_string()

      assert TypeDecoder.decode(data, [{:array, {:uint, 256}, 6}]) == [[7, 3, 0, 0, 0, 5]]
    end

    test "with a fixed-length array of dynamic data" do
      types = [{:array, :string, 3}]
      result = [["foo", "bar", "baz"]]

      encoded_pattern =
        """
        0000000000000000000000000000000000000000000000000000000000000020
        0000000000000000000000000000000000000000000000000000000000000060
        00000000000000000000000000000000000000000000000000000000000000a0
        00000000000000000000000000000000000000000000000000000000000000e0
        0000000000000000000000000000000000000000000000000000000000000003
        666f6f0000000000000000000000000000000000000000000000000000000000
        0000000000000000000000000000000000000000000000000000000000000003
        6261720000000000000000000000000000000000000000000000000000000000
        0000000000000000000000000000000000000000000000000000000000000003
        62617a0000000000000000000000000000000000000000000000000000000000
        """
        |> encode_multiline_string()

      encoded_result = TypeEncoder.encode(result, types)
      IO.inspect("encoded_result:")
      IO.inspect(Base.encode16(encoded_result, case: :lower))
      IO.inspect("encoded_pattern:")
      IO.inspect(Base.encode16(encoded_pattern, case: :lower))
      # assert encoded_result = encoded_pattern # todo
      assert result == encoded_result |> TypeDecoder.decode(types)
    end

    test "with multiple types" do
      types = [
        {:uint, 256},
        {:array, {:uint, 32}},
        {:bytes, 10},
        :bytes
      ]

      encoded_pattern =
        """
        0000000000000000000000000000000000000000000000000000000000000123
        0000000000000000000000000000000000000000000000000000000000000080
        3132333435363738393000000000000000000000000000000000000000000000
        00000000000000000000000000000000000000000000000000000000000000e0
        0000000000000000000000000000000000000000000000000000000000000002
        0000000000000000000000000000000000000000000000000000000000000456
        0000000000000000000000000000000000000000000000000000000000000789
        000000000000000000000000000000000000000000000000000000000000000d
        48656c6c6f2c20776f726c642100000000000000000000000000000000000000
        """
        |> encode_multiline_string()

      result = [0x123, [0x456, 0x789], "1234567890", "Hello, world!"]
      encoded_result = TypeEncoder.encode(result, types)
      assert encoded_result == encoded_pattern
      assert result == encoded_result |> TypeDecoder.decode(types)
    end

    test "with mixed multiple types" do
      types = [
        {:uint, 256},
        :string,
        {:uint, 8},
        :string
      ]

      encoded_data_bytes =
        """
        00000000000000000000000000000000000000000000000000000000000003e8
        0000000000000000000000000000000000000000000000000000000000000080
        0000000000000000000000000000000000000000000000000000000000000012
        00000000000000000000000000000000000000000000000000000000000000c0
        0000000000000000000000000000000000000000000000000000000000000003
        7473740000000000000000000000000000000000000000000000000000000000
        0000000000000000000000000000000000000000000000000000000000000004
        5445535400000000000000000000000000000000000000000000000000000000
        """
        |> encode_multiline_string()

      result = [0x3E8, "tst", 0x12, "TEST"]
      assert TypeEncoder.encode(result, types) == encoded_data_bytes
      assert result == TypeEncoder.encode(result, types) |> TypeDecoder.decode(types)
    end

    test "with static tuple" do
      data =
        """
        0000000000000000000000000000000000000000000000000000000000000123
        3132333435363738393000000000000000000000000000000000000000000000
        """
        |> encode_multiline_string()

      assert TypeDecoder.decode(data, [{:tuple, [{:uint, 256}, {:bytes, 10}]}]) == [
               {0x123, "1234567890"}
             ]
    end

    test "with dynamic tuple" do
      types = [{:tuple, [:bytes, {:uint, 256}, :string]}]
      result = [{"dave", 0x123, "Hello, world!"}]

      encoded_pattern =
        """
        0000000000000000000000000000000000000000000000000000000000000060
        0000000000000000000000000000000000000000000000000000000000000123
        00000000000000000000000000000000000000000000000000000000000000a0
        0000000000000000000000000000000000000000000000000000000000000004
        6461766500000000000000000000000000000000000000000000000000000000
        000000000000000000000000000000000000000000000000000000000000000d
        48656c6c6f2c20776f726c642100000000000000000000000000000000000000
        """
        |> encode_multiline_string()

      encoded_result = TypeEncoder.encode(result, types)
      assert encoded_result == encoded_pattern

      assert result == encoded_result |> TypeDecoder.decode(types)
    end

    # test "with the output of an executed contract" do
    #   encoded_pattern =
    #     """
    #     0000000000000000000000000000000000000000000000000000000000000007
    #     0000000000000000000000000000000000000000000000000000000000000003
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000005
    #     0000000000000000000000000000000000000000000000000000000000000001
    #     00000000000000000000000000000000000000000000012413b856370914a000
    #     00000000000000000000000000000000000000000000012413b856370914a000
    #     00000000000000000000000000000000000000000000000053444835ec580000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000003e73362871420000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000001
    #     0000000000000000000000000000000000000000000000000000000000000001
    #     0000000000000000000000000000000000000000000000000000000000000001
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000001
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000000000000000000000000
    #     0000000000000000000000000000000000000000000001212f67eff9a8ac801a
    #     0000000000000000000000000000000000000000000001212f67eff9a8ac8010
    #     0000000000000000000000000000000000000000000000000000000000000001
    #     0000000000000000000000000000000000000000000000000000000000000001
    #     0000000000000000000000000000000000000000000000000000000000000009
    #     436172746167656e610000000000000000000000000000000000000000000000
    #     """
    #     |> encode_multiline_string()

    #   expected = [
    #     [7, 3, 0, 0, 0, 5],
    #     true,
    #     [
    #       0x12413B856370914A000,
    #       0x12413B856370914A000,
    #       0x53444835EC580000,
    #       0,
    #       0x3E73362871420000,
    #       0,
    #       0,
    #       0,
    #       0,
    #       0,
    #       0,
    #       0,
    #       0,
    #       0,
    #       0,
    #       0,
    #       0,
    #       0,
    #       0,
    #       0,
    #       0,
    #       0,
    #       0,
    #       0
    #     ],
    #     [
    #       true,
    #       true,
    #       true,
    #       false,
    #       true,
    #       false,
    #       false,
    #       false,
    #       false,
    #       false,
    #       false,
    #       false,
    #       false,
    #       false,
    #       false,
    #       false,
    #       false,
    #       false,
    #       false,
    #       false,
    #       false,
    #       false,
    #       false,
    #       false
    #     ],
    #     0x1212F67EFF9A8AC801A,
    #     0x1212F67EFF9A8AC8010,
    #     1,
    #     1,
    #     "Cartagena"
    #   ]

    #   assert TypeDecoder.decode(encoded_pattern, [
    #            {:array, {:uint, 256}, 6},
    #            :bool,
    #            {:array, {:uint, 256}, 24},
    #            {:array, :bool, 24},
    #            {:uint, 256},
    #            {:uint, 256},
    #            {:uint, 256},
    #            {:uint, 256},
    #            :string
    #          ]) == expected
    # end

    test "with the output of an executed contract (simplified)" do
      encoded_pattern =
        """
        0000000000000000000000000000000000000000000000000000000000000007
        0000000000000000000000000000000000000000000000000000000000000003
        0000000000000000000000000000000000000000000000000000000000000000
        0000000000000000000000000000000000000000000000000000000000000000
        0000000000000000000000000000000000000000000000000000000000000000
        0000000000000000000000000000000000000000000000000000000000000005
        0000000000000000000000000000000000000000000000000000000000000001
        0000000000000000000000000000000000000000000000000013243d4c58de80
        0000000000000000000000000000000000000000000000000013242f54119620
        000000000000000000000000000000000000000000000000000000000000001e
        0000000000000000000000000000000000000000000000000000000000000000
        0000000000000000000000000000000000000000000000000000000000000028
        0000000000000000000000000000000000000000000000000000000000000001
        0000000000000000000000000000000000000000000000000000000000000001
        0000000000000000000000000000000000000000000000000000000000000001
        0000000000000000000000000000000000000000000000000000000000000000
        0000000000000000000000000000000000000000000000000000000000000001
        0000000000000000000000000000000000000000000000000012f6c3c41bca38
        0000000000000000000000000000000000000000000000000016b1bbf11f79d8
        0000000000000000000000000000000000000000000000000000000000000001
        0000000000000000000000000000000000000000000000000000000000000001
        00000000000000000000000000000000000000000000000000000000000002c0
        0000000000000000000000000000000000000000000000000000000000000009
        436172746167656e610000000000000000000000000000000000000000000000
        """
        |> encode_multiline_string()

      expected = [
        [7, 3, 0, 0, 0, 5],
        true,
        [
          5_387_870_250_000_000,
          5_387_810_250_004_000,
          30,
          0,
          40
        ],
        [
          true,
          true,
          true,
          false,
          true
        ],
        5_337_870_250_003_000,
        6_387_870_250_007_000,
        1,
        1,
        "Cartagena"
      ]

      assert TypeDecoder.decode(encoded_pattern, [
               {:array, {:uint, 256}, 6},
               :bool,
               {:array, {:uint, 256}, 5},
               {:array, :bool, 5},
               {:uint, 256},
               {:uint, 256},
               {:uint, 256},
               {:uint, 256},
               :string
             ]) == expected
    end

    test "sample from Solidity docs 1" do
        encoded_pattern =
          """
          0000000000000000000000000000000000000000000000000000000000000040
          00000000000000000000000000000000000000000000000000000000000000ea
          0000000000000000000000000000000000000000000000000000000000000008
          48656c6c6f212521000000000000000000000000000000000000000000000000
          """
          |> encode_multiline_string()

        res =
          encoded_pattern
          |> ABI.TypeDecoder.decode(%ABI.FunctionSelector{
            function: nil,
            types: [
              {:tuple, [:string, {:uint, 256}]}
            ]
          })

        assert res == [{"Hello!%!", 234}]
      end

    #   test "temp" do # the same as in doctest
    #     encoded = ABI.TypeEncoder.encode([{"awesome", true}], [{:tuple, [:string, :bool]}])

    #     encoded_pattern =
    #       """
    #       0000000000000000000000000000000000000000000000000000000000000040
    #       0000000000000000000000000000000000000000000000000000000000000001
    #       0000000000000000000000000000000000000000000000000000000000000007
    #       617765736f6d6500000000000000000000000000000000000000000000000000
    #       """
    #       |> encode_multiline_string()

    #     assert encoded == encoded_pattern

    #     res =
    #       encoded
    #       |> ABI.TypeDecoder.decode(%ABI.FunctionSelector{
    #         function: nil,
    #         types: [
    #           {:tuple, [:string, :bool]}
    #         ]
    #       })

    #     assert res == [{"awesome", true}]
    #   end
  end

  defp encode_multiline_string(data) do
    data
    |> String.split("\n", trim: true)
    |> Enum.join()
    |> Base.decode16!(case: :mixed)
  end
end
